12.136
pascal
var
  word: string;
  k: integer;
  firstChar: char;
  i: integer;
begin
  write('Введите слово: ');
  readln(word);
  write('Введите k: ');
  readln(k);
  
  if (length(word) > 1) and (k >= 1) and (k <= length(word)) then
  begin
    firstChar := word[1];
    // Сдвигаем символы 2..k влево
    for i := 1 to k-1 do
      word[i] := word[i+1];
    // Помещаем первую букву на место k
    word[k] := firstChar;
    
    writeln('Результат: ', word);
  end
  else
    writeln('Некорректные данные');
end.
12.137
pascal
var
  word: string;
begin
  word := 'алигортм';
  
  // Перемещаем буквы для получения "алгоритм"
  // 1. Запоминаем 'р' (позиция 6)
  // 2. Удаляем 'р'
  delete(word, 6, 1);
  // 3. Вставляем 'р' после 'о' (позиция 5)
  insert('р', word, 6);
  
  writeln('Было: алигортм');
  writeln('Стало: ', word);
end.
12.138
pascal
var
  word: string;
  s, k: integer;
  sChar: char;
  i: integer;
begin
  write('Введите слово: ');
  readln(word);
  write('Введите s (s < k): ');
  readln(s);
  write('Введите k: ');
  readln(k);
  
  if (s >= 1) and (k <= length(word)) and (s < k) then
  begin
    sChar := word[s];
    // Сдвигаем символы s+1..k влево
    for i := s to k-1 do
      word[i] := word[i+1];
    // Помещаем s-ю букву на место k
    word[k] := sChar;
    
    writeln('Результат: ', word);
  end
  else
    writeln('Некорректные данные');
end.
12.139
pascal
var
  word: string;
begin
  word := 'роцессорп';
  
  // Перемещаем буквы для получения "процессор"
  // Последнюю 'п' перемещаем в начало
  word := word[length(word)] + copy(word, 1, length(word)-1);
  
  writeln('Было: роцессорп');
  writeln('Стало: ', word);
end.
12.140
pascal
var
  word: string;
  lastChar: char;
  i: integer;
begin
  write('Введите слово: ');
  readln(word);
  
  if length(word) > 1 then
  begin
    lastChar := word[length(word)];
    // Сдвигаем символы вправо
    for i := length(word) downto 2 do
      word[i] := word[i-1];
    // Помещаем последнюю букву в начало
    word[1] := lastChar;
    
    writeln('Результат: ', word);
  end
  else
    writeln('Слово слишком короткое');
end.
12.141
pascal
var
  word: string;
begin
  word := 'ИТЕРНЕТН';
  
  // Перемещаем буквы для получения "ИНТЕРНЕТ"
  // 'Н' с конца перемещаем после 'Т' (позиция 2)
  word := copy(word, 1, 2) + 'Н' + copy(word, 3, length(word)-3);
  
  writeln('Было: ИТЕРНЕТН');
  writeln('Стало: ', word);
end.
12.142
pascal
var
  word: string;
  k: integer;
  lastChar: char;
  i: integer;
begin
  write('Введите слово: ');
  readln(word);
  write('Введите k: ');
  readln(k);
  
  if (length(word) > 1) and (k >= 1) and (k <= length(word)) then
  begin
    lastChar := word[length(word)];
    // Сдвигаем символы k..предпоследний вправо
    for i := length(word) downto k+1 do
      word[i] := word[i-1];
    // Помещаем последнюю букву на место k
    word[k] := lastChar;
    
    writeln('Результат: ', word);
  end
  else
    writeln('Некорректные данные');
end.
12.143
pascal
var
  word: string;
begin
  word := 'килбайот';
  
  // Перемещаем буквы для получения "килобайт"
  // 1. 'о' находится на позиции 6, перемещаем её на позицию 4
  // 2. Сдвигаем остальные буквы
  word := copy(word, 1, 3) + 'о' + copy(word, 4, 3) + 'т';
  
  writeln('Было: килбайот');
  writeln('Стало: ', word);
end.
12.144
pascal
var
  word: string;
  s, k: integer;
  sChar: char;
  i: integer;
begin
  write('Введите слово: ');
  readln(word);
  write('Введите s (s > k): ');
  readln(s);
  write('Введите k: ');
  readln(k);
  
  if (s >= 1) and (k >= 1) and (s <= length(word)) and 
     (k <= length(word)) and (s > k) then
  begin
    sChar := word[s];
    // Сдвигаем символы k..s-1 вправо
    for i := s downto k+1 do
      word[i] := word[i-1];
    // Помещаем s-ю букву на место k
    word[k] := sChar;
    
    writeln('Результат: ', word);
  end
  else
    writeln('Некорректные данные');
end.
12.145
pascal
var
  word, result: string;
  i: integer;
begin
  write('Введите слово из 12 букв: ');
  readln(word);
  
  if length(word) = 12 then
  begin
    result := '';
    for i := 1 to 6 do
      result := result + word[i] + word[13-i];
    
    writeln('Результат: ', result);
  end
  else
    writeln('Слово должно содержать 12 букв');
end.
12.146
pascal
var
  str: string;
  i: integer;
begin
  write('Введите строку: ');
  readln(str);
  
  for i := 1 to length(str) do
  begin
    case str[i] of
      'а': str[i] := 'б';
      'б': str[i] := 'а';
      'А': str[i] := 'Б';
      'Б': str[i] := 'А';
    end;
  end;
  
  writeln('Результат: ', str);
end.
12.147
pascal
var
  ch: char;
begin
  write('Введите символ: ');
  readln(ch);
  
  if (ch >= '0') and (ch <= '9') then
    writeln('Символ является цифрой')
  else
    writeln('Символ не является цифрой');
end.
12.148
pascal
var
  text: string;
  i: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  writeln('Цифры в тексте:');
  for i := 1 to length(text) do
    if (text[i] >= '0') and (text[i] <= '9') then
      writeln(text[i]);
end.
12.149
pascal
var
  text: string;
  i, count: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  count := 0;
  for i := 1 to length(text) do
    if (text[i] >= '0') and (text[i] <= '9') then
      count := count + 1;
  
  writeln('Количество цифр: ', count);
end.
12.150
pascal
var
  text: string;
  i, sum, maxDigit, digit: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  // а) Найти сумму цифр
  sum := 0;
  for i := 1 to length(text) do
    if (text[i] >= '0') and (text[i] <= '9') then
      sum := sum + ord(text[i]) - ord('0');
  
  writeln('а) Сумма цифр: ', sum);
  
  // б) Найти максимальную цифру
  maxDigit := -1;
  for i := 1 to length(text) do
    if (text[i] >= '0') and (text[i] <= '9') then
    begin
      digit := ord(text[i]) - ord('0');
      if digit > maxDigit then
        maxDigit := digit;
    end;
  
  if maxDigit >= 0 then
    writeln('б) Максимальная цифра: ', maxDigit)
  else
    writeln('б) Цифр в тексте нет');
end.
12.151
pascal
var
  text: string;
  i, maxDigit, maxPos, digit, firstNonSpace: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  // Находим первый символ, не являющийся пробелом
  firstNonSpace := 1;
  while (firstNonSpace <= length(text)) and (text[firstNonSpace] = ' ') do
    firstNonSpace := firstNonSpace + 1;
  
  if firstNonSpace <= length(text) then
  begin
    // Ищем максимальную цифру
    maxDigit := -1;
    maxPos := -1;
    
    for i := firstNonSpace to length(text) do
      if (text[i] >= '0') and (text[i] <= '9') then
      begin
        digit := ord(text[i]) - ord('0');
        if digit > maxDigit then
        begin
          maxDigit := digit;
          maxPos := i;
        end;
      end;
    
    if maxPos > 0 then
      writeln('Порядковый номер максимальной цифры: ', maxPos)
    else
      writeln('В тексте нет цифр');
  end
  else
    writeln('Текст состоит только из пробелов');
end.
12.152
pascal
var
  text: string;
  i: integer;
  isNumber: boolean;
begin
  write('Введите текст: ');
  readln(text);
  
  isNumber := true;
  
  // Проверяем каждый символ
  for i := 1 to length(text) do
    if not ((text[i] >= '0') and (text[i] <= '9')) then
      isNumber := false;
  
  // Проверяем, что первая цифра не '0' (кроме случая, когда число 0)
  if (length(text) > 1) and (text[1] = '0') then
    isNumber := false;
  
  if isNumber then
    writeln('Текст является правильной десятичной записью целого числа')
  else
    writeln('Текст не является правильной десятичной записью целого числа');
end.
12.153
pascal
var
  text: string;
  i, sum: integer;
begin
  write('Введите десятичную запись целого числа: ');
  readln(text);
  
  sum := 0;
  for i := 1 to length(text) do
    if (text[i] >= '0') and (text[i] <= '9') then
      sum := sum + ord(text[i]) - ord('0');
  
  writeln('Сумма цифр числа: ', sum);
end.
12.154
pascal
var
  text: string;
  i, sum, currentNumber: integer;
begin
  write('Введите выражение вида "d1+d2+...+dn": ');
  readln(text);
  
  sum := 0;
  currentNumber := 0;
  
  for i := 1 to length(text) do
  begin
    if (text[i] >= '0') and (text[i] <= '9') then
      currentNumber := currentNumber * 10 + (ord(text[i]) - ord('0'))
    else if text[i] = '+' then
    begin
      sum := sum + currentNumber;
      currentNumber := 0;
    end;
  end;
  
  // Добавляем последнее число
  sum := sum + currentNumber;
  
  writeln('Сумма: ', sum);
end.
12.155
pascal
var
  text: string;
  i, sum, currentNumber, sign: integer;
begin
  write('Введите выражение вида "d1-d2+d3-...": ');
  readln(text);
  
  sum := 0;
  currentNumber := 0;
  sign := 1;  // 1 для плюса, -1 для минуса
  
  for i := 1 to length(text) do
  begin
    if (text[i] >= '0') and (text[i] <= '9') then
      currentNumber := currentNumber * 10 + (ord(text[i]) - ord('0'))
    else if (text[i] = '+') or (text[i] = '-') then
    begin
      sum := sum + sign * currentNumber;
      currentNumber := 0;
      if text[i] = '+' then
        sign := 1
      else
        sign := -1;
    end;
  end;
  
  // Добавляем последнее число
  sum := sum + sign * currentNumber;
  
  writeln('Алгебраическая сумма: ', sum);
end.
12.156
pascal
var
  text: string;
  i, sum, currentNumber, sign: integer;
begin
  write('Введите выражение вида "d1±d2±...±dn": ');
  readln(text);
  
  sum := 0;
  currentNumber := 0;
  sign := 1;  // 1 для плюса, -1 для минуса
  
  // Первое число всегда с плюсом
  for i := 1 to length(text) do
  begin
    if (text[i] >= '0') and (text[i] <= '9') then
      currentNumber := currentNumber * 10 + (ord(text[i]) - ord('0'))
    else if (text[i] = '+') or (text[i] = '-') then
    begin
      sum := sum + sign * currentNumber;
      currentNumber := 0;
      if text[i] = '+' then
        sign := 1
      else
        sign := -1;
    end;
  end;
  
  // Добавляем последнее число
  sum := sum + sign * currentNumber;
  
  writeln('Алгебраическая сумма: ', sum);
end.
12.157
pascal
var
  text: string;
  i, currentCount, maxCount: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  currentCount := 0;
  maxCount := 0;
  
  for i := 1 to length(text) do
  begin
    if (text[i] >= '0') and (text[i] <= '9') then
      currentCount := currentCount + 1
    else
    begin
      if currentCount > maxCount then
        maxCount := currentCount;
      currentCount := 0;
    end;
  end;
  
  // Проверяем последовательность в конце текста
  if currentCount > maxCount then
    maxCount := currentCount;
  
  writeln('Наибольшее количество идущих подряд цифр: ', maxCount);
end.
12.158
pascal
var
  text: string;
  i, start, number: integer;
  found: boolean;
begin
  write('Введите текст: ');
  readln(text);
  
  found := false;
  start := 0;
  
  // Находим начало последовательности цифр
  for i := 1 to length(text) do
    if (text[i] >= '0') and (text[i] <= '9') then
    begin
      start := i;
      found := true;
      break;
    end;
  
  if found then
  begin
    // Считываем число
    number := 0;
    i := start;
    while (i <= length(text)) and (text[i] >= '0') and (text[i] <= '9') do
    begin
      number := number * 10 + (ord(text[i]) - ord('0'));
      i := i + 1;
    end;
    
    writeln('Число, образованное цифрами: ', number);
  end
  else
    writeln('В тексте нет цифр');
end.
12.159
pascal
var
  text: string;
  i, sum, currentNumber: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  sum := 0;
  currentNumber := 0;
  
  for i := 1 to length(text) do
  begin
    if (text[i] >= '0') and (text[i] <= '9') then
      currentNumber := currentNumber * 10 + (ord(text[i]) - ord('0'))
    else
    begin
      sum := sum + currentNumber;
      currentNumber := 0;
    end;
  end;
  
  // Добавляем последнее число, если оно есть
  sum := sum + currentNumber;
  
  writeln('Сумма всех чисел в тексте: ', sum);
end.
12.160
pascal
var
  text: string;
  i, currentNumber, maxNumber: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  currentNumber := 0;
  maxNumber := 0;
  
  for i := 1 to length(text) do
  begin
    if (text[i] >= '0') and (text[i] <= '9') then
      currentNumber := currentNumber * 10 + (ord(text[i]) - ord('0'))
    else
    begin
      if currentNumber > maxNumber then
        maxNumber := currentNumber;
      currentNumber := 0;
    end;
  end;
  
  // Проверяем число в конце текста
  if currentNumber > maxNumber then
    maxNumber := currentNumber;
  
  if maxNumber > 0 then
    writeln('Максимальное число в тексте: ', maxNumber)
  else
    writeln('В тексте нет чисел');
end.
12.161
pascal
var
  numStr: string;
  n: integer;
begin
  write('Введите натуральное число: ');
  readln(numStr);
  
  // Просто выводим длину строки
  writeln('Количество цифр в числе: ', length(numStr));
end.
12.162
pascal
var
  numStr, intPart, fracPart: string;
  dotPos, i: integer;
begin
  write('Введите положительное вещественное число: ');
  readln(numStr);
  
  // Находим позицию точки
  dotPos := pos('.', numStr);
  if dotPos = 0 then
    dotPos := pos(',', numStr);  // для запятой
  
  if dotPos > 0 then
  begin
    // а) Целая часть
    intPart := copy(numStr, 1, dotPos-1);
    writeln('а) Количество цифр в целой части: ', length(intPart));
    
    // б) Дробная часть
    fracPart := copy(numStr, dotPos+1, length(numStr)-dotPos);
    writeln('б) Количество цифр в дробной части: ', length(fracPart));
  end
  else
  begin
    writeln('а) Количество цифр в целой части: ', length(numStr));
    writeln('б) Дробной части нет');
  end;
end.
12.163
pascal
var
  expr: string;
  i, sum, currentNumber: integer;
begin
  write('Введите выражение вида "1+25+3" (без пробелов): ');
  readln(expr);
  
  sum := 0;
  currentNumber := 0;
  
  for i := 1 to length(expr) do
  begin
    if (expr[i] >= '0') and (expr[i] <= '9') then
      currentNumber := currentNumber * 10 + (ord(expr[i]) - ord('0'))
    else if expr[i] = '+' then
    begin
      sum := sum + currentNumber;
      currentNumber := 0;
    end;
  end;
  
  // Добавляем последнее число
  sum := sum + currentNumber;
  
  writeln('Сумма: ', sum);
end.
12.164 (повышенная сложность)
pascal
var
  sentence: string;
  i, currentCount, maxCount: integer;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  currentCount := 0;
  maxCount := 0;
  
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
      currentCount := currentCount + 1
    else
    begin
      if currentCount > maxCount then
        maxCount := currentCount;
      currentCount := 0;
    end;
  end;
  
  // Проверяем пробелы в конце
  if currentCount > maxCount then
    maxCount := currentCount;
  
  writeln('Наибольшее количество идущих подряд пробелов: ', maxCount);
end.
12.165 (повышенная сложность)
pascal
var
  text: string;
  i, currentCount, maxCount: integer;
begin
  write('Введите текст: ');
  readln(text);
  
  if length(text) > 0 then
  begin
    currentCount := 1;
    maxCount := 1;
    
    for i := 2 to length(text) do
    begin
      if text[i] = text[i-1] then
        currentCount := currentCount + 1
      else
        currentCount := 1;
      
      if currentCount > maxCount then
        maxCount := currentCount;
    end;
    
    writeln('Наибольшее количество идущих подряд одинаковых символов: ', maxCount);
  end
  else
    writeln('Текст пустой');
end.
12.166 (повышенная сложность)
pascal
var
  word: string;
  i, j, count: integer;
  unique: boolean;
begin
  write('Введите слово: ');
  readln(word);
  
  count := 0;
  
  for i := 1 to length(word) do
  begin
    unique := true;
    
    // Проверяем, встречалась ли эта буква ранее
    for j := 1 to i-1 do
      if word[i] = word[j] then
      begin
        unique := false;
        break;
      end;
    
    if unique then
      count := count + 1;
  end;
  
  writeln('Количество различных букв в слове: ', count);
end.
12.167 (повышенная сложность)
pascal
var
  word: string;
  i, j: integer;
  found: boolean;
begin
  write('Введите слово: ');
  readln(word);
  
  found := false;
  
  for i := 1 to length(word)-1 do
  begin
    for j := i+1 to length(word) do
    begin
      if word[i] = word[j] then
      begin
        writeln('Одинаковые буквы: "', word[i], '" на позициях ', i, ' и ', j);
        found := true;
        break;
      end;
    end;
    if found then break;
  end;
  
  if not found then
    writeln('В слове нет двух одинаковых букв');
end.
12.168 (повышенная сложность)
pascal
var
  word1, word2: string;
  i: integer;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  
  write('Ответ: ');
  for i := 1 to length(word1) do
  begin
    if pos(word1[i], word2) > 0 then
      write('да ')
    else
      write('нет ');
  end;
  writeln;
end.
12.169 (повышенная сложность)
pascal
var
  word1, word2: string;
  i: integer;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  
  write('Ответ: ');
  for i := 1 to length(word1) do
  begin
    // Проверяем, была ли эта буква уже рассмотрена
    if pos(word1[i], copy(word1, 1, i-1)) = 0 then
    begin
      if pos(word1[i], word2) > 0 then
        write('да ')
      else
        write('нет ');
    end;
  end;
  writeln;
end.
12.170 (повешенная сложность)
pascal
var
  word1, word2: string;
  i: integer;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  
  write('Буквы, которые есть только в одном из слов: ');
  
  // Буквы из первого слова, которых нет во втором
  for i := 1 to length(word1) do
    if pos(word1[i], word2) = 0 then
      write(word1[i], ' ');
  
  // Буквы из второго слова, которых нет в первом
  for i := 1 to length(word2) do
    if pos(word2[i], word1) = 0 then
      write(word2[i], ' ');
  
  writeln;
end.
12.171 (повышенная сложность)
pascal
var
  word1, word2: string;
  i: integer;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  
  write('Буквы, которые встречаются в обоих словах лишь один раз: ');
  
  // Проверяем каждую букву первого слова
  for i := 1 to length(word1) do
  begin
    // Если буква встречается в первом слове 1 раз
    if (length(word1) - length(stringreplace(word1, word1[i], '', [rfReplaceAll])) = 1) and
       // И встречается во втором слове 1 раз
       (length(word2) - length(stringreplace(word2, word1[i], '', [rfReplaceAll])) = 1) then
      write(word1[i], ' ');
  end;
  
  writeln;
end.
12.172 (повышенная сложность)
pascal
var
  word1, word2: string;
  i, j: integer;
  canForm1, canForm2: boolean;
  tempWord: string;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  
  // Вариант 1: повторяющиеся буквы второго слова могут в первом слове не повторяться
  canForm1 := true;
  for i := 1 to length(word2) do
  begin
    if pos(word2[i], word1) = 0 then
    begin
      canForm1 := false;
      break;
    end;
  end;
  
  if canForm1 then
    writeln('Вариант 1: можно получить второе слово из букв первого')
  else
    writeln('Вариант 1: нельзя получить второе слово из букв первого');
  
  // Вариант 2: каждая буква второго слова должна входить в первое слово столько же раз
  canForm2 := true;
  tempWord := word1;
  
  for i := 1 to length(word2) do
  begin
    j := pos(word2[i], tempWord);
    if j = 0 then
    begin
      canForm2 := false;
      break;
    end
    else
      delete(tempWord, j, 1);
  end;
  
  if canForm2 then
    writeln('Вариант 2: можно получить второе слово из букв первого')
  else
    writeln('Вариант 2: нельзя получить второе слово из букв первого');
end.
12.173 (повышенная сложность)
pascal
var
  word1, word2, word3: string;
  i: integer;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  write('Введите третье слово: ');
  readln(word3);
  
  writeln('Вариант 1 (с повторяющимися буквами):');
  write('Буквы, которые есть только в одном из слов: ');
  
  // Буквы из первого слова
  for i := 1 to length(word1) do
    if (pos(word1[i], word2) = 0) and (pos(word1[i], word3) = 0) then
      write(word1[i], ' ');
  
  // Буквы из второго слова
  for i := 1 to length(word2) do
    if (pos(word2[i], word1) = 0) and (pos(word2[i], word3) = 0) then
      write(word2[i], ' ');
  
  // Буквы из третьего слова
  for i := 1 to length(word3) do
    if (pos(word3[i], word1) = 0) and (pos(word3[i], word2) = 0) then
      write(word3[i], ' ');
  
  writeln;
  
  writeln('Вариант 2 (без повторяющихся букв):');
  write('Буквы, которые есть только в одном из слов: ');
  
  // Буквы из первого слова
  for i := 1 to length(word1) do
    if (pos(word1[i], copy(word1, 1, i-1)) = 0) and
       (pos(word1[i], word2) = 0) and (pos(word1[i], word3) = 0) then
      write(word1[i], ' ');
  
  // Буквы из второго слова
  for i := 1 to length(word2) do
    if (pos(word2[i], copy(word2, 1, i-1)) = 0) and
       (pos(word2[i], word1) = 0) and (pos(word2[i], word3) = 0) then
      write(word2[i], ' ');
  
  // Буквы из третьего слова
  for i := 1 to length(word3) do
    if (pos(word3[i], copy(word3, 1, i-1)) = 0) and
       (pos(word3[i], word1) = 0) and (pos(word3[i], word2) = 0) then
      write(word3[i], ' ');
  
  writeln;
end.
12.174 (повышенная сложность)
pascal
var
  word1, word2, word3: string;
  i: integer;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  write('Введите третье слово: ');
  readln(word3);
  
  write('Общие буквы всех трех слов: ');
  
  // Проверяем буквы первого слова
  for i := 1 to length(word1) do
  begin
    // Если буква встречается в первом слове впервые
    if (pos(word1[i], copy(word1, 1, i-1)) = 0) and
       // И есть во втором слове
       (pos(word1[i], word2) > 0) and
       // И есть в третьем слове
       (pos(word1[i], word3) > 0) then
      write(word1[i], ' ');
  end;
  
  writeln;
end.
12.175 (повышенная сложность)
pascal
var
  word1, word2, word3, allWords: string;
  i: integer;
begin
  write('Введите первое слово: ');
  readln(word1);
  write('Введите второе слово: ');
  readln(word2);
  write('Введите третье слово: ');
  readln(word3);
  
  allWords := word1 + word2 + word3;
  
  write('Неповторяющиеся буквы: ');
  
  for i := 1 to length(allWords) do
  begin
    // Если буква встречается в объединенной строке только один раз
    if length(allWords) - length(stringreplace(allWords, allWords[i], '', [rfReplaceAll])) = 1 then
      write(allWords[i], ' ');
  end;
  
  writeln;
end.
12.176 (слова в массиве)
pascal
var
  sentence: string;
  words: array[1..10] of string;
  i, wordCount, posStart, posEnd: integer;
begin
  write('Введите предложение из 10 слов: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
      
      if wordCount = 10 then
        break;
    end;
  end;
  
  // Последнее слово
  if (wordCount < 10) and (posStart <= length(sentence)) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Выводим массив слов
  writeln('Массив слов:');
  for i := 1 to wordCount do
    writeln(i, ': ', words[i]);
end.
12.177 (обратный порядок слов)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart: integer;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Выводим в обратном порядке
  write('Предложение в обратном порядке слов: ');
  for i := wordCount downto 1 do
    write(words[i], ' ');
  writeln;
end.
12.178 (поменять местами первое и последнее слова)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart: integer;
  temp: string;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  if wordCount >= 2 then
  begin
    // Меняем местами первое и последнее слова
    temp := words[1];
    words[1] := words[wordCount];
    words[wordCount] := temp;
    
    // Выводим результат
    write('Результат: ');
    for i := 1 to wordCount do
      write(words[i], ' ');
    writeln;
  end
  else
    writeln('В предложении меньше двух слов');
end.
12.179 (слова, отличные от "привет")
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart: integer;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Выводим слова, отличные от "привет"
  writeln('Слова, отличные от "привет":');
  for i := 1 to wordCount do
    if words[i] <> 'привет' then
      writeln(words[i]);
end.
12.180 (количество слов)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart, countA, countB: integer;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // а) начинающихся с буквы а
  countA := 0;
  for i := 1 to wordCount do
    if (length(words[i]) > 0) and (words[i][1] = 'а') then
      countA := countA + 1;
  
  // б) оканчивающихся буквой я
  countB := 0;
  for i := 1 to wordCount do
    if (length(words[i]) > 0) and (words[i][length(words[i])] = 'я') then
      countB := countB + 1;
  
  writeln('а) Количество слов, начинающихся с буквы "а": ', countA);
  writeln('б) Количество слов, оканчивающихся буквой "я": ', countB);
end.
12.181 (различные условия для слов)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, j, wordCount, posStart, countO: integer;
  sameStartEnd, hasA: boolean;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  writeln('а) Слова, начинающиеся и оканчивающиеся на одну букву:');
  for i := 1 to wordCount do
    if (length(words[i]) > 0) and (words[i][1] = words[i][length(words[i])]) then
      writeln('  ', words[i]);
  
  writeln('б) Слова, которые содержат ровно три буквы "о":');
  for i := 1 to wordCount do
  begin
    countO := 0;
    for j := 1 to length(words[i]) do
      if words[i][j] = 'о' then
        countO := countO + 1;
    
    if countO = 3 then
      writeln('  ', words[i]);
  end;
  
  writeln('в) Слова, которые содержат хотя бы одну букву "а":');
  for i := 1 to wordCount do
  begin
    hasA := false;
    for j := 1 to length(words[i]) do
      if words[i][j] = 'а' then
      begin
        hasA := true;
        break;
      end;
    
    if hasA then
      writeln('  ', words[i]);
  end;
end.
12.182 (слово, начинающееся на букву к)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart: integer;
  found: boolean;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  found := false;
  
  // Разбиваем на слова и сразу ищем слово на "к"
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      
      // Проверяем текущее слово
      if (not found) and (length(words[wordCount]) > 0) and (words[wordCount][1] = 'к') then
      begin
        writeln('Найдено слово, начинающееся на "к": ', words[wordCount]);
        found := true;
      end;
      
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
    
    if (not found) and (length(words[wordCount]) > 0) and (words[wordCount][1] = 'к') then
    begin
      writeln('Найдено слово, начинающееся на "к": ', words[wordCount]);
      found := true;
    end;
  end;
  
  if not found then
    writeln('Слов, начинающихся на "к", не найдено');
end.
12.183 (длина самого короткого слова)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart, minLength: integer;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Находим минимальную длину
  if wordCount > 0 then
  begin
    minLength := length(words[1]);
    for i := 2 to wordCount do
      if length(words[i]) < minLength then
        minLength := length(words[i]);
    
    writeln('Длина самого короткого слова: ', minLength);
  end
  else
    writeln('В предложении нет слов');
end.
12.184 (самое длинное слово)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart, maxLength, maxIndex: integer;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Находим самое длинное слово
  if wordCount > 0 then
  begin
    maxLength := length(words[1]);
    maxIndex := 1;
    
    for i := 2 to wordCount do
      if length(words[i]) > maxLength then
      begin
        maxLength := length(words[i]);
        maxIndex := i;
      end;
    
    writeln('Самое длинное слово: ', words[maxIndex]);
    writeln('Его длина: ', maxLength);
  end
  else
    writeln('В предложении нет слов');
end.
12.185 (проверка длины самого длинного слова)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, wordCount, posStart, maxLength: integer;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Находим максимальную длину
  if wordCount > 0 then
  begin
    maxLength := length(words[1]);
    for i := 2 to wordCount do
      if length(words[i]) > maxLength then
        maxLength := length(words[i]);
    
    if maxLength > 10 then
      writeln('Да, самое длинное слово имеет больше 10 символов')
    else
      writeln('Нет, самое длинное слово имеет не больше 10 символов');
  end
  else
    writeln('В предложении нет слов');
end.
12.186 (слова в порядке неубывания длин)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, j, wordCount, posStart: integer;
  temp: string;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Сортируем слова по длине (пузырьковая сортировка)
  for i := 1 to wordCount-1 do
    for j := 1 to wordCount-i do
      if length(words[j]) > length(words[j+1]) then
      begin
        temp := words[j];
        words[j] := words[j+1];
        words[j+1] := temp;
      end;
  
  // Выводим результат
  writeln('Слова в порядке неубывания их длин:');
  for i := 1 to wordCount do
    writeln(words[i], ' (длина: ', length(words[i]), ')');
end.
12.187 (слова, встречающиеся по одному разу)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, j, wordCount, posStart, count: integer;
  isUnique: boolean;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Находим слова, встречающиеся по одному разу
  writeln('Слова, встречающиеся по одному разу:');
  for i := 1 to wordCount do
  begin
    count := 0;
    for j := 1 to wordCount do
      if words[i] = words[j] then
        count := count + 1;
    
    if count = 1 then
      writeln(words[i]);
  end;
end.
12.188 (различные слова)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, j, wordCount, posStart: integer;
  isUnique: boolean;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Находим различные слова
  writeln('Различные слова в предложении:');
  for i := 1 to wordCount do
  begin
    isUnique := true;
    // Проверяем, встречалось ли это слово ранее
    for j := 1 to i-1 do
      if words[i] = words[j] then
      begin
        isUnique := false;
        break;
      end;
    
    if isUnique then
      writeln(words[i]);
  end;
end.
12.189 (два одинаковых слова)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, j, wordCount, posStart: integer;
  found: boolean;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  found := false;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Ищем два одинаковых слова
  for i := 1 to wordCount-1 do
  begin
    for j := i+1 to wordCount do
      if words[i] = words[j] then
      begin
        writeln('Найдены одинаковые слова: "', words[i], '"');
        found := true;
        break;
      end;
    if found then break;
  end;
  
  if not found then
    writeln('Одинаковых слов не найдено');
end.
12.190 (преобразование слов по правилам)
pascal
var
  sentence: string;
  words: array[1..100] of string;
  i, j, k, wordCount, posStart, maxLength, maxIndex: integer;
  tempWord: string;
  ch: char;
begin
  write('Введите предложение: ');
  readln(sentence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sentence) do
  begin
    if sentence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sentence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sentence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sentence, posStart, length(sentence)-posStart+1);
  end;
  
  // Находим самое длинное слово
  maxLength := 0;
  maxIndex := 1;
  for i := 1 to wordCount do
    if length(words[i]) > maxLength then
    begin
      maxLength := length(words[i]);
      maxIndex := i;
    end;
  
  writeln('Преобразованные слова:');
  
  for i := 1 to wordCount do
  begin
    tempWord := words[i];
    
    // а) заменить первую встреченную букву a на о
    for j := 1 to length(tempWord) do
      if tempWord[j] = 'а' then
      begin
        tempWord[j] := 'о';
        break;
      end;
    
    // б) удалить из слова все вхождения последней буквы (кроме нее самой)
    if length(tempWord) > 0 then
    begin
      ch := tempWord[length(tempWord)];
      for j := length(tempWord)-1 downto 1 do
        if tempWord[j] = ch then
          delete(tempWord, j, 1);
    end;
    
    // в) оставить в слове только первые вхождения каждой буквы
    for j := length(tempWord) downto 1 do
      for k := 1 to j-1 do
        if tempWord[j] = tempWord[k] then
        begin
          delete(tempWord, j, 1);
          break;
        end;
    
    // г) в самом длинном слове удалить среднюю(средние) букву(ы)
    if i = maxIndex then
    begin
      if length(tempWord) mod 2 = 1 then
        delete(tempWord, length(tempWord) div 2 + 1, 1)
      else
        delete(tempWord, length(tempWord) div 2, 2);
    end;
    
    writeln('  ', words[i], ' -> ', tempWord);
  end;
end.
12.191 (последовательность слов с условиями)
pascal
var
  sequence: string;
  words: array[1..100] of string;
  i, j, k, wordCount, posStart: integer;
  hasRepeats, isSymmetric: boolean;
begin
  write('Введите последовательность слов: ');
  readln(sequence);
  
  wordCount := 0;
  posStart := 1;
  
  // Разбиваем на слова
  for i := 1 to length(sequence) do
  begin
    if sequence[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(sequence, posStart, i-posStart);
      posStart := i + 1;
    end;
  end;
  
  // Последнее слово
  if posStart <= length(sequence) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(sequence, posStart, length(sequence)-posStart+1);
  end;
  
  if wordCount > 0 then
  begin
    // а) слова, отличные от первого и без повторяющихся букв
    writeln('а) Слова, отличные от первого и без повторяющихся букв:');
    for i := 2 to wordCount do
      if words[i] <> words[1] then
      begin
        hasRepeats := false;
        for j := 1 to length(words[i])-1 do
          for k := j+1 to length(words[i]) do
            if words[i][j] = words[i][k] then
              hasRepeats := true;
        
        if not hasRepeats then
          writeln('  ', words[i]);
      end;
    
    // б) слова, отличные от первого и симметричные
    writeln('б) Слова, отличные от первого и симметричные:');
    for i := 2 to wordCount do
      if words[i] <> words[1] then
      begin
        isSymmetric := true;
        for j := 1 to length(words[i]) div 2 do
          if words[i][j] <> words[i][length(words[i])-j+1] then
            isSymmetric := false;
        
        if isSymmetric then
          writeln('  ', words[i]);
      end;
  end;
end.





:

12.192 (слова первого предложения во втором)
pascal
var
  sentence1, sentence2: string;
  words1, words2: array[1..100] of string;
  wordCount1, wordCount2, i, j, posStart: integer;
  found: boolean;
begin
  writeln('Введите первое предложение: ');
  readln(sentence1);
  writeln('Введите второе предложение: ');
  readln(sentence2);
  
  // Разбиваем первое предложение на слова
  wordCount1 := 0;
  posStart := 1;
  for i := 1 to length(sentence1) do
    if sentence1[i] = ' ' then
    begin
      wordCount1 := wordCount1 + 1;
      words1[wordCount1] := copy(sentence1, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence1) then
  begin
    wordCount1 := wordCount1 + 1;
    words1[wordCount1] := copy(sentence1, posStart, length(sentence1)-posStart+1);
  end;
  
  // Разбиваем второе предложение на слова
  wordCount2 := 0;
  posStart := 1;
  for i := 1 to length(sentence2) do
    if sentence2[i] = ' ' then
    begin
      wordCount2 := wordCount2 + 1;
      words2[wordCount2] := copy(sentence2, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence2) then
  begin
    wordCount2 := wordCount2 + 1;
    words2[wordCount2] := copy(sentence2, posStart, length(sentence2)-posStart+1);
  end;
  
  // Проверяем каждое слово первого предложения
  writeln('Результат (для каждого слова первого предложения):');
  for i := 1 to wordCount1 do
  begin
    found := false;
    for j := 1 to wordCount2 do
      if words1[i] = words2[j] then
      begin
        found := true;
        break;
      end;
    
    if found then
      writeln('Слово "', words1[i], '" входит во второе предложение')
    else
      writeln('Слово "', words1[i], '" не входит во второе предложение');
  end;
end.
12.193 (слова первого предложения во втором, без повторений)
pascal
var
  sentence1, sentence2: string;
  words1, words2: array[1..100] of string;
  wordCount1, wordCount2, i, j, k, posStart: integer;
  found, alreadyChecked: boolean;
begin
  writeln('Введите первое предложение: ');
  readln(sentence1);
  writeln('Введите второе предложение: ');
  readln(sentence2);
  
  // Разбиваем первое предложение на слова
  wordCount1 := 0;
  posStart := 1;
  for i := 1 to length(sentence1) do
    if sentence1[i] = ' ' then
    begin
      wordCount1 := wordCount1 + 1;
      words1[wordCount1] := copy(sentence1, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence1) then
  begin
    wordCount1 := wordCount1 + 1;
    words1[wordCount1] := copy(sentence1, posStart, length(sentence1)-posStart+1);
  end;
  
  // Разбиваем второе предложение на слова
  wordCount2 := 0;
  posStart := 1;
  for i := 1 to length(sentence2) do
    if sentence2[i] = ' ' then
    begin
      wordCount2 := wordCount2 + 1;
      words2[wordCount2] := copy(sentence2, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence2) then
  begin
    wordCount2 := wordCount2 + 1;
    words2[wordCount2] := copy(sentence2, posStart, length(sentence2)-posStart+1);
  end;
  
  // Проверяем каждое уникальное слово первого предложения
  writeln('Результат (для уникальных слов первого предложения):');
  for i := 1 to wordCount1 do
  begin
    // Проверяем, не проверяли ли мы уже это слово
    alreadyChecked := false;
    for k := 1 to i-1 do
      if words1[i] = words1[k] then
      begin
        alreadyChecked := true;
        break;
      end;
    
    if not alreadyChecked then
    begin
      found := false;
      for j := 1 to wordCount2 do
        if words1[i] = words2[j] then
        begin
          found := true;
          break;
        end;
      
      if found then
        writeln('Слово "', words1[i], '" входит во второе предложение')
      else
        writeln('Слово "', words1[i], '" не входит во второе предложение');
    end;
  end;
end.
12.194 (слова, которые есть только в одном из предложений)
pascal
var
  sentence1, sentence2: string;
  words1, words2: array[1..100] of string;
  wordCount1, wordCount2, i, j, posStart: integer;
  found: boolean;
begin
  writeln('Введите первое предложение: ');
  readln(sentence1);
  writeln('Введите второе предложение: ');
  readln(sentence2);
  
  // Разбиваем первое предложение на слова
  wordCount1 := 0;
  posStart := 1;
  for i := 1 to length(sentence1) do
    if sentence1[i] = ' ' then
    begin
      wordCount1 := wordCount1 + 1;
      words1[wordCount1] := copy(sentence1, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence1) then
  begin
    wordCount1 := wordCount1 + 1;
    words1[wordCount1] := copy(sentence1, posStart, length(sentence1)-posStart+1);
  end;
  
  // Разбиваем второе предложение на слова
  wordCount2 := 0;
  posStart := 1;
  for i := 1 to length(sentence2) do
    if sentence2[i] = ' ' then
    begin
      wordCount2 := wordCount2 + 1;
      words2[wordCount2] := copy(sentence2, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence2) then
  begin
    wordCount2 := wordCount2 + 1;
    words2[wordCount2] := copy(sentence2, posStart, length(sentence2)-posStart+1);
  end;
  
  // Слова из первого предложения, которых нет во втором
  writeln('Слова, которые есть только в одном из предложений:');
  for i := 1 to wordCount1 do
  begin
    found := false;
    for j := 1 to wordCount2 do
      if words1[i] = words2[j] then
      begin
        found := true;
        break;
      end;
    
    if not found then
      writeln('  "', words1[i], '" - только в первом предложении');
  end;
  
  // Слова из второго предложения, которых нет в первом
  for i := 1 to wordCount2 do
  begin
    found := false;
    for j := 1 to wordCount1 do
      if words2[i] = words1[j] then
      begin
        found := true;
        break;
      end;
    
    if not found then
      writeln('  "', words2[i], '" - только во втором предложении');
  end;
end.
12.195 (слова, встречающиеся в двух предложениях только один раз)
pascal
var
  sentence1, sentence2: string;
  words1, words2: array[1..100] of string;
  wordCount1, wordCount2, i, j, k, posStart, count1, count2: integer;
begin
  writeln('Введите первое предложение: ');
  readln(sentence1);
  writeln('Введите второе предложение: ');
  readln(sentence2);
  
  // Разбиваем первое предложение на слова
  wordCount1 := 0;
  posStart := 1;
  for i := 1 to length(sentence1) do
    if sentence1[i] = ' ' then
    begin
      wordCount1 := wordCount1 + 1;
      words1[wordCount1] := copy(sentence1, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence1) then
  begin
    wordCount1 := wordCount1 + 1;
    words1[wordCount1] := copy(sentence1, posStart, length(sentence1)-posStart+1);
  end;
  
  // Разбиваем второе предложение на слова
  wordCount2 := 0;
  posStart := 1;
  for i := 1 to length(sentence2) do
    if sentence2[i] = ' ' then
    begin
      wordCount2 := wordCount2 + 1;
      words2[wordCount2] := copy(sentence2, posStart, i-posStart);
      posStart := i + 1;
    end;
  if posStart <= length(sentence2) then
  begin
    wordCount2 := wordCount2 + 1;
    words2[wordCount2] := copy(sentence2, posStart, length(sentence2)-posStart+1);
  end;
  
  // Проверяем все слова первого предложения
  writeln('Слова, встречающиеся в двух предложениях только один раз:');
  
  // Сначала слова из первого предложения
  for i := 1 to wordCount1 do
  begin
    // Считаем, сколько раз слово встречается в первом предложении
    count1 := 0;
    for j := 1 to wordCount1 do
      if words1[i] = words1[j] then
        count1 := count1 + 1;
    
    // Считаем, сколько раз слово встречается во втором предложении
    count2 := 0;
    for j := 1 to wordCount2 do
      if words1[i] = words2[j] then
        count2 := count2 + 1;
    
    // Если слово встречается ровно 1 раз в обоих предложениях
    if (count1 = 1) and (count2 = 1) then
    begin
      // Проверяем, не выводили ли мы уже это слово
      found := false;
      for k := 1 to i-1 do
        if words1[i] = words1[k] then
        begin
          found := true;
          break;
        end;
      
      if not found then
        writeln('  "', words1[i], '"');
    end;
  end;
  
  // Теперь слова из второго предложения, которых нет в первом
  for i := 1 to wordCount2 do
  begin
    // Считаем, сколько раз слово встречается во втором предложении
    count2 := 0;
    for j := 1 to wordCount2 do
      if words2[i] = words2[j] then
        count2 := count2 + 1;
    
    // Проверяем, есть ли это слово в первом предложении
    count1 := 0;
    for j := 1 to wordCount1 do
      if words2[i] = words1[j] then
        count1 := count1 + 1;
    
    // Если слово встречается только во втором предложении 1 раз
    if (count2 = 1) and (count1 = 0) then
    begin
      // Проверяем, не выводили ли мы уже это слово
      found := false;
      for k := 1 to i-1 do
        if words2[i] = words2[k] then
        begin
          found := true;
          break;
        end;
      
      if not found then
        writeln('  "', words2[i], '"');
    end;
  end;
end.
12.196 (проверка круглых скобок - простой случай)
pascal
var
  text: string;
  i, balance: integer;
  correct: boolean;
begin
  write('Введите текст с круглыми скобками: ');
  readln(text);
  
  // а) Простая проверка
  balance := 0;
  correct := true;
  
  for i := 1 to length(text) do
  begin
    if text[i] = '(' then
      balance := balance + 1
    else if text[i] = ')' then
    begin
      balance := balance - 1;
      if balance < 0 then  // лишняя закрывающая скобка
        correct := false;
    end;
  end;
  
  if balance > 0 then  // лишние открывающие скобки
    correct := false;
  
  if correct then
    writeln('а) Скобки расставлены правильно: да')
  else
    writeln('а) Скобки расставлены правильно: нет');
  
  // б) Подробная проверка
  balance := 0;
  for i := 1 to length(text) do
  begin
    if text[i] = '(' then
      balance := balance + 1
    else if text[i] = ')' then
    begin
      balance := balance - 1;
      if balance < 0 then
      begin
        writeln('б) Ошибка: лишняя закрывающая скобка на позиции ', i);
        exit;
      end;
    end;
  end;
  
  if balance = 0 then
    writeln('б) Скобки расставлены правильно')
  else
    writeln('б) Ошибка: ', balance, ' лишних открывающих скобок');
end.
12.197 (проверка скобок с вложенными скобками)
pascal
var
  expr: string;
  i, balance: integer;
  correct: boolean;
begin
  write('Введите арифметическое выражение со скобками: ');
  readln(expr);
  
  // а) Простая проверка
  balance := 0;
  correct := true;
  
  for i := 1 to length(expr) do
  begin
    if expr[i] = '(' then
      balance := balance + 1
    else if expr[i] = ')' then
    begin
      balance := balance - 1;
      if balance < 0 then  // лишняя закрывающая скобка
        correct := false;
    end;
  end;
  
  if balance > 0 then  // лишние открывающие скобки
    correct := false;
  
  if correct then
    writeln('а) Скобки расставлены правильно: да')
  else
    writeln('а) Скобки расставлены правильно: нет');
  
  // б) Подробная проверка
  balance := 0;
  for i := 1 to length(expr) do
  begin
    if expr[i] = '(' then
      balance := balance + 1
    else if expr[i] = ')' then
    begin
      balance := balance - 1;
      if balance < 0 then
      begin
        writeln('б) Ошибка: лишняя закрывающая скобка на позиции ', i);
        exit;
      end;
    end;
  end;
  
  if balance = 0 then
    writeln('б) Скобки расставлены правильно')
  else
    writeln('б) Ошибка: ', balance, ' лишних открывающих скобок');
end.
12.198 (выравнивание текста по ширине)
pascal
var
  text, result: string;
  words: array[1..100] of string;
  wordCount, i, j, totalSpacesNeeded, spacesBetween, extraSpaces, posStart: integer;
  targetLength: integer;
begin
  write('Введите текст (без начальных и конечных пробелов): ');
  readln(text);
  write('Введите требуемую длину строки: ');
  readln(targetLength);
  
  // Проверяем, что требуемая длина не меньше исходной
  if targetLength < length(text) then
  begin
    writeln('Требуемая длина меньше исходной длины текста');
    exit;
  end;
  
  // Разбиваем текст на слова
  wordCount := 0;
  posStart := 1;
  for i := 1 to length(text) do
    if text[i] = ' ' then
    begin
      wordCount := wordCount + 1;
      words[wordCount] := copy(text, posStart, i-posStart);
      posStart := i + 1;
    end;
  
  // Последнее слово
  if posStart <= length(text) then
  begin
    wordCount := wordCount + 1;
    words[wordCount] := copy(text, posStart, length(text)-posStart+1);
  end;
  
  // Вычисляем, сколько пробелов нужно добавить
  totalSpacesNeeded := targetLength - length(text);
  
  // Если только одно слово
  if wordCount = 1 then
  begin
    result := words[1];
    while length(result) < targetLength do
      result := result + ' ';
  end
  else
  begin
    // Вычисляем базовое количество пробелов между словами
    spacesBetween := totalSpacesNeeded div (wordCount - 1);
    // Вычисляем, сколько пробелов нужно распределить дополнительно
    extraSpaces := totalSpacesNeeded mod (wordCount - 1);
    
    // Формируем результат
    result := words[1];
    for i := 2 to wordCount do
    begin
      // Добавляем пробелы
      for j := 1 to 1 + spacesBetween do  // 1 исходный пробел + дополнительные
        result := result + ' ';
      
      // Распределяем дополнительные пробелы
      if i-1 <= extraSpaces then
        result := result + ' ';
      
      // Добавляем слово
      result := result + words[i];
    end;
  end;
  
  writeln('Выровненный текст:');
  writeln(result);
  writeln('Длина строки: ', length(result));
end.
12.199 (число словами на русском)
pascal
var
  n: integer;
  
  function DigitToWord(digit: integer): string;
  begin
    case digit of
      0: DigitToWord := 'ноль';
      1: DigitToWord := 'один';
      2: DigitToWord := 'два';
      3: DigitToWord := 'три';
      4: DigitToWord := 'четыре';
      5: DigitToWord := 'пять';
      6: DigitToWord := 'шесть';
      7: DigitToWord := 'семь';
      8: DigitToWord := 'восемь';
      9: DigitToWord := 'девять';
      10: DigitToWord := 'десять';
      11: DigitToWord := 'одиннадцать';
      12: DigitToWord := 'двенадцать';
      13: DigitToWord := 'тринадцать';
      14: DigitToWord := 'четырнадцать';
      15: DigitToWord := 'пятнадцать';
      16: DigitToWord := 'шестнадцать';
      17: DigitToWord := 'семнадцать';
      18: DigitToWord := 'восемнадцать';
      19: DigitToWord := 'девятнадцать';
      else DigitToWord := '';
    end;
  end;
  
  function TensToWord(tens: integer): string;
  begin
    case tens of
      2: TensToWord := 'двадцать';
      3: TensToWord := 'тридцать';
      4: TensToWord := 'сорок';
      5: TensToWord := 'пятьдесят';
      6: TensToWord := 'шестьдесят';
      7: TensToWord := 'семьдесят';
      8: TensToWord := 'восемьдесят';
      9: TensToWord := 'девяносто';
      else TensToWord := '';
    end;
  end;
  
  function HundredsToWord(hundreds: integer): string;
  begin
    case hundreds of
      1: HundredsToWord := 'сто';
      2: HundredsToWord := 'двести';
      3: HundredsToWord := 'триста';
      4: HundredsToWord := 'четыреста';
      5: HundredsToWord := 'пятьсот';
      6: HundredsToWord := 'шестьсот';
      7: HundredsToWord := 'семьсот';
      8: HundredsToWord := 'восемьсот';
      9: HundredsToWord := 'девятьсот';
      else HundredsToWord := '';
    end;
  end;
  
  function NumberToWords(num: integer): string;
  var
    resultStr: string;
    hundreds, tens, units: integer;
  begin
    if num = 0 then
    begin
      NumberToWords := 'ноль';
      exit;
    end;
    
    if num = 1000 then
    begin
      NumberToWords := 'тысяча';
      exit;
    end;
    
    resultStr := '';
    
    // Сотни
    hundreds := num div 100;
    if hundreds > 0 then
      resultStr := resultStr + HundredsToWord(hundreds) + ' ';
    
    // Десятки и единицы
    tens := (num mod 100) div 10;
    units := num mod 10;
    
    if (num mod 100) >= 10 then
    begin
      if (num mod 100) < 20 then
        resultStr := resultStr + DigitToWord(num mod 100)
      else
      begin
        resultStr := resultStr + TensToWord(tens);
        if units > 0 then
          resultStr := resultStr + ' ' + DigitToWord(units);
      end;
    end
    else if units > 0 then
      resultStr := resultStr + DigitToWord(units);
    
    // Удаляем лишний пробел в конце
    if resultStr[length(resultStr)] = ' ' then
      delete(resultStr, length(resultStr), 1);
    
    NumberToWords := resultStr;
  end;

begin
  write('Введите натуральное число (n ≤ 1000): ');
  readln(n);
  
  if (n < 0) or (n > 1000) then
    writeln('Число должно быть от 0 до 1000')
  else
    writeln('Число словами: ', NumberToWords(n));
end.
Примечания к решениям:

Задачи 12.196-12.197: Алгоритм проверки скобок основан на подсчете баланса. Каждая открывающая скобка увеличивает баланс, каждая закрывающая - уменьшает. Если баланс становится отрицательным - есть лишняя закрывающая скобка. Если в конце баланс положительный - есть лишние открывающие скобки.

Задача 12.198: Алгоритм выравнивания текста:

Разбиваем текст на слова

Вычисляем, сколько пробелов нужно добавить

Распределяем пробелы равномерно между словами

Если пробелов нельзя распределить поровну, добавляем лишние пробелы к первым промежуткам

Задача 12.199: Алгоритм преобразования числа в слова:

Обрабатываем особые случаи (0, 1000)

Разбиваем число на сотни, десятки и единицы

Особое внимание уделяем числам 11-19, которые имеют собственные названия

Формируем строку по частям

Все решения готовы к компиляции и выполнению в среде Pascal.


/
